<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vgg: Linear&lt; maxB, IC, nC &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vgg
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structLinear-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Linear&lt; maxB, IC, nC &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>linear (fully connected) layer  
 <a href="structLinear.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="linear_8h_source.html">linear.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Linear&lt; maxB, IC, nC &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structLinear__coll__graph.png" border="0" usemap="#Linear_3_01maxB_00_01IC_00_01nC_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="Linear_3_01maxB_00_01IC_00_01nC_01_4_coll__map" id="Linear_3_01maxB_00_01IC_00_01nC_01_4_coll__map">
<area shape="rect" id="node2" href="structarray4.html" title="array4\&lt; maxB, nC, 1, 1 \&gt;" alt="" coords="168,5,339,32"/>
<area shape="rect" id="node3" href="structcmdline__opt.html" title="command line options " alt="" coords="5,72,97,99"/>
<area shape="rect" id="node6" href="structlogger.html" title="logging object " alt="" coords="225,119,282,145"/>
<area shape="rect" id="node4" href="structarray4.html" title="array4\&lt; maxB, IC, 1, 1 \&gt;" alt="" coords="169,169,337,196"/>
<area shape="rect" id="node5" href="structarray2.html" title="array2\&lt; IC, nC \&gt;" alt="" coords="193,229,314,256"/>
<area shape="rect" id="node7" href="structtsc__t.html" title="timestamp " alt="" coords="26,137,77,164"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a45f2c4c010a2451d39e0a7e736fd4a58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a45f2c4c010a2451d39e0a7e736fd4a58">init</a> (<a class="el" href="structcmdline__opt.html">cmdline_opt</a> <a class="el" href="structLinear.html#ad6b0173f0baf5ce07b3cd7340d4ed0d4">opt</a>, <a class="el" href="structlogger.html">logger</a> *<a class="el" href="structLinear.html#acde13832b627b3c1113283e22bac77a7">lgr</a>, <a class="el" href="structrnd__gen__t.html">rnd_gen_t</a> &amp;rg)</td></tr>
<tr class="memdesc:a45f2c4c010a2451d39e0a7e736fd4a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize  <a href="#a45f2c4c010a2451d39e0a7e736fd4a58">More...</a><br /></td></tr>
<tr class="separator:a45f2c4c010a2451d39e0a7e736fd4a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7811cf3a3731974b668f7e973a79f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a0c7811cf3a3731974b668f7e973a79f4">copy</a> ()</td></tr>
<tr class="memdesc:a0c7811cf3a3731974b668f7e973a79f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a copy of this  <a href="#a0c7811cf3a3731974b668f7e973a79f4">More...</a><br /></td></tr>
<tr class="separator:a0c7811cf3a3731974b668f7e973a79f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6dcb67669d4984b6b9a676d4f14177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a0c6dcb67669d4984b6b9a676d4f14177">set_dev</a> (<a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt; *<a class="el" href="structLinear.html#a84bf1832fbbaccc87ca3e13b45f5acb4">dev</a>)</td></tr>
<tr class="memdesc:a0c6dcb67669d4984b6b9a676d4f14177"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the device pointer for this and all subobjects  <a href="#a0c6dcb67669d4984b6b9a676d4f14177">More...</a><br /></td></tr>
<tr class="separator:a0c6dcb67669d4984b6b9a676d4f14177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf7edf669cf1182b49b604a2c9b3212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#aecf7edf669cf1182b49b604a2c9b3212">make_dev</a> ()</td></tr>
<tr class="memdesc:aecf7edf669cf1182b49b604a2c9b3212"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the algorithm is a gpu algorithm, allocate a device shadow of this object and set dev field of this and all subobjects. otherwise it sets all dev fields to null.  <a href="#aecf7edf669cf1182b49b604a2c9b3212">More...</a><br /></td></tr>
<tr class="separator:aecf7edf669cf1182b49b604a2c9b3212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad691fa515105ec71c69eed5f0ae03af6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#ad691fa515105ec71c69eed5f0ae03af6">del_dev</a> ()</td></tr>
<tr class="memdesc:ad691fa515105ec71c69eed5f0ae03af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the algorithm is a gpu algorithm, dev field must not be null and deallocate it.  <a href="#ad691fa515105ec71c69eed5f0ae03af6">More...</a><br /></td></tr>
<tr class="separator:ad691fa515105ec71c69eed5f0ae03af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c57d7c3b7e25ae73f8bc3b5bb49992"><td class="memItemLeft" align="right" valign="top"><a id="a36c57d7c3b7e25ae73f8bc3b5bb49992"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a36c57d7c3b7e25ae73f8bc3b5bb49992">to_dev</a> ()</td></tr>
<tr class="memdesc:a36c57d7c3b7e25ae73f8bc3b5bb49992"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the algorithm is a gpu algorithm, dev field must not be null and send the host data to the device memory <br /></td></tr>
<tr class="separator:a36c57d7c3b7e25ae73f8bc3b5bb49992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf0ae6b25a12dbe31194a283e075feb"><td class="memItemLeft" align="right" valign="top"><a id="a2cf0ae6b25a12dbe31194a283e075feb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a2cf0ae6b25a12dbe31194a283e075feb">to_host</a> ()</td></tr>
<tr class="memdesc:a2cf0ae6b25a12dbe31194a283e075feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the algorithm is a gpu algorithm, dev field must not be null and send the device data to the host memory <br /></td></tr>
<tr class="separator:a2cf0ae6b25a12dbe31194a283e075feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59e1addd962ac7a70993229534ab899"><td class="memItemLeft" align="right" valign="top">__device__ __host__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#aa59e1addd962ac7a70993229534ab899">update_base</a> (<a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> eta)</td></tr>
<tr class="memdesc:aa59e1addd962ac7a70993229534ab899"><td class="mdescLeft">&#160;</td><td class="mdescRight">the baseline (serial) implementation of update called both by cpu implementation (update_cpu) and gpu implementation (update_dev). the call sequence update -&gt; update_cpu -&gt; update_base on cpu and and is update -&gt; update_gpu -&gt; update_global -&gt; update_dev -&gt; update_base  <a href="#aa59e1addd962ac7a70993229534ab899">More...</a><br /></td></tr>
<tr class="separator:aa59e1addd962ac7a70993229534ab899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45413b0c13ca0ca89db6a3217a8b00b"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#ad45413b0c13ca0ca89db6a3217a8b00b">update_dev</a> (<a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> eta)</td></tr>
<tr class="memdesc:ad45413b0c13ca0ca89db6a3217a8b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the device function of update called from the global (non-member) function  <a href="#ad45413b0c13ca0ca89db6a3217a8b00b">More...</a><br /></td></tr>
<tr class="separator:ad45413b0c13ca0ca89db6a3217a8b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca71565731b9d8c3ba552578c61753a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a8ca71565731b9d8c3ba552578c61753a">update_gpu</a> (<a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> eta)</td></tr>
<tr class="memdesc:a8ca71565731b9d8c3ba552578c61753a"><td class="mdescLeft">&#160;</td><td class="mdescRight">a gpu version of baseline code called from the entry function (update)  <a href="#a8ca71565731b9d8c3ba552578c61753a">More...</a><br /></td></tr>
<tr class="separator:a8ca71565731b9d8c3ba552578c61753a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabe5b3388c37c5b02e9f7ca7f0cd686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#afabe5b3388c37c5b02e9f7ca7f0cd686">update_cpu</a> (<a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> eta)</td></tr>
<tr class="memdesc:afabe5b3388c37c5b02e9f7ca7f0cd686"><td class="mdescLeft">&#160;</td><td class="mdescRight">a cpu version of baseline code called from the entry function (update)  <a href="#afabe5b3388c37c5b02e9f7ca7f0cd686">More...</a><br /></td></tr>
<tr class="separator:afabe5b3388c37c5b02e9f7ca7f0cd686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828a72af0a1ccac904325ee280dbefa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a828a72af0a1ccac904325ee280dbefa4">update</a> (<a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> eta)</td></tr>
<tr class="memdesc:a828a72af0a1ccac904325ee280dbefa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">update weights of all sublayers with gradients that must have been computed  <a href="#a828a72af0a1ccac904325ee280dbefa4">More...</a><br /></td></tr>
<tr class="separator:a828a72af0a1ccac904325ee280dbefa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb02d44e0558e4e26b9a550945cd3b7e"><td class="memItemLeft" align="right" valign="top">__device__ __host__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#adb02d44e0558e4e26b9a550945cd3b7e">forward_base</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:adb02d44e0558e4e26b9a550945cd3b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the baseline (serial) implementation of forward called both by cpu implementation (forward_cpu) and gpu implementation (forward_dev). the call sequence forward -&gt; forward_cpu -&gt; forward_base on cpu and and is forward -&gt; forward_gpu -&gt; forward_global -&gt; forward_dev -&gt; forward_base  <a href="#adb02d44e0558e4e26b9a550945cd3b7e">More...</a><br /></td></tr>
<tr class="separator:adb02d44e0558e4e26b9a550945cd3b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b86dba92137500810cbf3ed95ee1fcb"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a2b86dba92137500810cbf3ed95ee1fcb">forward_dev</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:a2b86dba92137500810cbf3ed95ee1fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">the device function of forward called from the global (non-member) function  <a href="#a2b86dba92137500810cbf3ed95ee1fcb">More...</a><br /></td></tr>
<tr class="separator:a2b86dba92137500810cbf3ed95ee1fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d794073640bad48f9722f5d40b98902"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a1d794073640bad48f9722f5d40b98902">forward_gpu</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:a1d794073640bad48f9722f5d40b98902"><td class="mdescLeft">&#160;</td><td class="mdescRight">a gpu version of baseline code called from the entry function (forward)  <a href="#a1d794073640bad48f9722f5d40b98902">More...</a><br /></td></tr>
<tr class="separator:a1d794073640bad48f9722f5d40b98902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f18ced52dc4bd6aa0ea45119c6a7e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a02f18ced52dc4bd6aa0ea45119c6a7e0">forward_cpu</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:a02f18ced52dc4bd6aa0ea45119c6a7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a cpu version of baseline code called from the entry function (forward)  <a href="#a02f18ced52dc4bd6aa0ea45119c6a7e0">More...</a><br /></td></tr>
<tr class="separator:a02f18ced52dc4bd6aa0ea45119c6a7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0294f2d1c2013f66d89a52474352e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#aed0294f2d1c2013f66d89a52474352e5">forward</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:aed0294f2d1c2013f66d89a52474352e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">calc the loss function of a mini-batch (x)  <a href="#aed0294f2d1c2013f66d89a52474352e5">More...</a><br /></td></tr>
<tr class="separator:aed0294f2d1c2013f66d89a52474352e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcabfb5486aad2c05dd94bae98acf168"><td class="memItemLeft" align="right" valign="top">__device__ __host__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#adcabfb5486aad2c05dd94bae98acf168">backward_base</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;gy)</td></tr>
<tr class="memdesc:adcabfb5486aad2c05dd94bae98acf168"><td class="mdescLeft">&#160;</td><td class="mdescRight">the baseline (serial) implementation of backward called both by cpu implementation (backward_cpu) and gpu implementation (backward_dev). the call sequence backward -&gt; backward_cpu -&gt; backward_base on cpu and and is backward -&gt; backward_gpu -&gt; backward_global -&gt; backward_dev -&gt; backward_base  <a href="#adcabfb5486aad2c05dd94bae98acf168">More...</a><br /></td></tr>
<tr class="separator:adcabfb5486aad2c05dd94bae98acf168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865f8dedc402675cd5cf240fcfbcd258"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a865f8dedc402675cd5cf240fcfbcd258">backward_dev</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;gy)</td></tr>
<tr class="memdesc:a865f8dedc402675cd5cf240fcfbcd258"><td class="mdescLeft">&#160;</td><td class="mdescRight">the device function of backward called from the global (non-member) function  <a href="#a865f8dedc402675cd5cf240fcfbcd258">More...</a><br /></td></tr>
<tr class="separator:a865f8dedc402675cd5cf240fcfbcd258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4936542d24da1357c1c7fb7f95d6ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#acc4936542d24da1357c1c7fb7f95d6ea">backward_gpu</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;gy)</td></tr>
<tr class="memdesc:acc4936542d24da1357c1c7fb7f95d6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">a gpu version of baseline code called from the entry function (backward)  <a href="#acc4936542d24da1357c1c7fb7f95d6ea">More...</a><br /></td></tr>
<tr class="separator:acc4936542d24da1357c1c7fb7f95d6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4bd03ccec0da8849c2536d32770a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#acd4bd03ccec0da8849c2536d32770a61">backward_cpu</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;gy)</td></tr>
<tr class="memdesc:acd4bd03ccec0da8849c2536d32770a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">a cpu version of baseline code called from the entry function (backward)  <a href="#acd4bd03ccec0da8849c2536d32770a61">More...</a><br /></td></tr>
<tr class="separator:acd4bd03ccec0da8849c2536d32770a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa39d38b876fbd70794621955193fd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#aeaa39d38b876fbd70794621955193fd3">backward</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;gy)</td></tr>
<tr class="memdesc:aeaa39d38b876fbd70794621955193fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">calc the gradient of loss wrt the input (x)  <a href="#aeaa39d38b876fbd70794621955193fd3">More...</a><br /></td></tr>
<tr class="separator:aeaa39d38b876fbd70794621955193fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab38b786325b4701080a89d5dab96f23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#aab38b786325b4701080a89d5dab96f23">rand_grad</a> (<a class="el" href="structrnd__gen__t.html">rnd_gen_t</a> &amp;rg, <a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> p, <a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> q)</td></tr>
<tr class="memdesc:aab38b786325b4701080a89d5dab96f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">randomly set all gradients to values between p and q  <a href="#aab38b786325b4701080a89d5dab96f23">More...</a><br /></td></tr>
<tr class="separator:aab38b786325b4701080a89d5dab96f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faa818e70d779b80663b361a1e7ef75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a4faa818e70d779b80663b361a1e7ef75">set_grad</a> (<a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt; &amp;o)</td></tr>
<tr class="memdesc:a4faa818e70d779b80663b361a1e7ef75"><td class="mdescLeft">&#160;</td><td class="mdescRight">set all gradients to gradients of another object  <a href="#a4faa818e70d779b80663b361a1e7ef75">More...</a><br /></td></tr>
<tr class="separator:a4faa818e70d779b80663b361a1e7ef75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af920adb0c630cddb4f8012984784807c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#af920adb0c630cddb4f8012984784807c">gw_dot_gw</a> (<a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt; &amp;o)</td></tr>
<tr class="memdesc:af920adb0c630cddb4f8012984784807c"><td class="mdescLeft">&#160;</td><td class="mdescRight">take the inner product of gradients  <a href="#af920adb0c630cddb4f8012984784807c">More...</a><br /></td></tr>
<tr class="separator:af920adb0c630cddb4f8012984784807c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a84bf1832fbbaccc87ca3e13b45f5acb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a84bf1832fbbaccc87ca3e13b45f5acb4">dev</a></td></tr>
<tr class="separator:a84bf1832fbbaccc87ca3e13b45f5acb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b0173f0baf5ce07b3cd7340d4ed0d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcmdline__opt.html">cmdline_opt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#ad6b0173f0baf5ce07b3cd7340d4ed0d4">opt</a></td></tr>
<tr class="separator:ad6b0173f0baf5ce07b3cd7340d4ed0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde13832b627b3c1113283e22bac77a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlogger.html">logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#acde13832b627b3c1113283e22bac77a7">lgr</a></td></tr>
<tr class="separator:acde13832b627b3c1113283e22bac77a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7c8ecf358de5e00589a722a0c4541c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a8a7c8ecf358de5e00589a722a0c4541c">x_ptr</a></td></tr>
<tr class="separator:a8a7c8ecf358de5e00589a722a0c4541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abe6ceff587b423273808d94b392ee8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray2.html">array2</a>&lt; IC, nC &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a5abe6ceff587b423273808d94b392ee8">w</a></td></tr>
<tr class="separator:a5abe6ceff587b423273808d94b392ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422f2130612692682fdd151b96899264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a422f2130612692682fdd151b96899264">y</a></td></tr>
<tr class="separator:a422f2130612692682fdd151b96899264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62267914d63b5f94379e4f9caf6b317c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray2.html">array2</a>&lt; IC, nC &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#a62267914d63b5f94379e4f9caf6b317c">gw</a></td></tr>
<tr class="separator:a62267914d63b5f94379e4f9caf6b317c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdbaef350ab7abbcb459cfa87961bba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinear.html#abcdbaef350ab7abbcb459cfa87961bba">gx</a></td></tr>
<tr class="separator:abcdbaef350ab7abbcb459cfa87961bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;idx_t maxB, idx_t IC, idx_t nC&gt;<br />
struct Linear&lt; maxB, IC, nC &gt;</h3>

<p>linear (fully connected) layer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(maxB)</td><td>the maximum number of images (batch size) </td></tr>
    <tr><td class="paramname">(IC)</td><td>the number of channels per input image (the original input has typically three channels for RGB. in hidden layers, it starts from 64 and goes up to 512 in the last hidden layer) </td></tr>
    <tr><td class="paramname">(nC)</td><td>number of classes (10) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aeaa39d38b876fbd70794621955193fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa39d38b876fbd70794621955193fd3">&#9670;&nbsp;</a></span>backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray4.html">array4</a>&lt;maxB,IC,1,1&gt;&amp; <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calc the gradient of loss wrt the input (x) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(gy)</td><td>gradient of loss with respect to the output</td></tr>
  </table>
  </dd>
</dl>
<p>calc the gradient of loss wrt the input. along the way, it also calculates the gradient of loss wrt weights for all sublayers that have weights. since this is the entire network, gy is actually a vector whose components are all 1. (loss = sum of losses of each data). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aed0294f2d1c2013f66d89a52474352e5" title="calc the loss function of a mini-batch (x) ">forward</a> </dd>
<dd>
<a class="el" href="structLinear.html#a828a72af0a1ccac904325ee280dbefa4" title="update weights of all sublayers with gradients that must have been computed ">update</a> </dd></dl>

</div>
</div>
<a id="adcabfb5486aad2c05dd94bae98acf168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcabfb5486aad2c05dd94bae98acf168">&#9670;&nbsp;</a></span>backward_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __host__ void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::backward_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the baseline (serial) implementation of backward called both by cpu implementation (backward_cpu) and gpu implementation (backward_dev). the call sequence backward -&gt; backward_cpu -&gt; backward_base on cpu and and is backward -&gt; backward_gpu -&gt; backward_global -&gt; backward_dev -&gt; backward_base </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(gy)</td><td>gradient of loss with respect to the output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aeaa39d38b876fbd70794621955193fd3" title="calc the gradient of loss wrt the input (x) ">backward</a> </dd>
<dd>
<a class="el" href="structLinear.html#acc4936542d24da1357c1c7fb7f95d6ea" title="a gpu version of baseline code called from the entry function (backward) ">backward_gpu</a> </dd>
<dd>
<a class="el" href="softmaxcrossentropy_8h.html#a47d56a9a23e08247b227f4aac17413e0" title="a global CUDA function that implements the baseline backward function for GPU ">backward_global</a> </dd>
<dd>
<a class="el" href="structLinear.html#a865f8dedc402675cd5cf240fcfbcd258" title="the device function of backward called from the global (non-member) function ">backward_dev</a> </dd></dl>

</div>
</div>
<a id="acd4bd03ccec0da8849c2536d32770a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4bd03ccec0da8849c2536d32770a61">&#9670;&nbsp;</a></span>backward_cpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::backward_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a cpu version of baseline code called from the entry function (backward) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(gy)</td><td>gradient of loss with respect to the output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aeaa39d38b876fbd70794621955193fd3" title="calc the gradient of loss wrt the input (x) ">backward</a> </dd>
<dd>
<a class="el" href="structLinear.html#adcabfb5486aad2c05dd94bae98acf168" title="the baseline (serial) implementation of backward called both by cpu implementation (backward_cpu) and...">backward_base</a> </dd></dl>

</div>
</div>
<a id="a865f8dedc402675cd5cf240fcfbcd258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865f8dedc402675cd5cf240fcfbcd258">&#9670;&nbsp;</a></span>backward_dev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::backward_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the device function of backward called from the global (non-member) function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(gy)</td><td>gradient of loss with respect to the output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aeaa39d38b876fbd70794621955193fd3" title="calc the gradient of loss wrt the input (x) ">backward</a> </dd>
<dd>
<a class="el" href="structLinear.html#acc4936542d24da1357c1c7fb7f95d6ea" title="a gpu version of baseline code called from the entry function (backward) ">backward_gpu</a> </dd>
<dd>
<a class="el" href="softmaxcrossentropy_8h.html#a47d56a9a23e08247b227f4aac17413e0" title="a global CUDA function that implements the baseline backward function for GPU ">backward_global</a> </dd>
<dd>
<a class="el" href="structLinear.html#adcabfb5486aad2c05dd94bae98acf168" title="the baseline (serial) implementation of backward called both by cpu implementation (backward_cpu) and...">backward_base</a> </dd></dl>

</div>
</div>
<a id="acc4936542d24da1357c1c7fb7f95d6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4936542d24da1357c1c7fb7f95d6ea">&#9670;&nbsp;</a></span>backward_gpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::backward_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, nC, 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a gpu version of baseline code called from the entry function (backward) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(gy)</td><td>gradient of loss with respect to the output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aeaa39d38b876fbd70794621955193fd3" title="calc the gradient of loss wrt the input (x) ">backward</a> </dd>
<dd>
<a class="el" href="softmaxcrossentropy_8h.html#a47d56a9a23e08247b227f4aac17413e0" title="a global CUDA function that implements the baseline backward function for GPU ">backward_global</a> </dd>
<dd>
<a class="el" href="structLinear.html#a865f8dedc402675cd5cf240fcfbcd258" title="the device function of backward called from the global (non-member) function ">backward_dev</a> </dd>
<dd>
<a class="el" href="structLinear.html#adcabfb5486aad2c05dd94bae98acf168" title="the baseline (serial) implementation of backward called both by cpu implementation (backward_cpu) and...">backward_base</a> </dd></dl>

</div>
</div>
<a id="a0c7811cf3a3731974b668f7e973a79f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7811cf3a3731974b668f7e973a79f4">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLinear.html">Linear</a>&lt;maxB,IC,nC&gt;* <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make a copy of this </p>
<p>if this object has a device pointer, the copy will have a device pointer too, but its contents are NOT copied </p>

</div>
</div>
<a id="ad691fa515105ec71c69eed5f0ae03af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad691fa515105ec71c69eed5f0ae03af6">&#9670;&nbsp;</a></span>del_dev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::del_dev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if the algorithm is a gpu algorithm, dev field must not be null and deallocate it. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aecf7edf669cf1182b49b604a2c9b3212" title="if the algorithm is a gpu algorithm, allocate a device shadow of this object and set dev field of thi...">make_dev</a> </dd>
<dd>
<a class="el" href="structLinear.html#a0c6dcb67669d4984b6b9a676d4f14177" title="set the device pointer for this and all subobjects ">set_dev</a> </dd></dl>

</div>
</div>
<a id="aed0294f2d1c2013f66d89a52474352e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0294f2d1c2013f66d89a52474352e5">&#9670;&nbsp;</a></span>forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray4.html">array4</a>&lt;maxB,nC,1,1&gt;&amp; <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calc the loss function of a mini-batch (x) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x)</td><td>input images </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aeaa39d38b876fbd70794621955193fd3" title="calc the gradient of loss wrt the input (x) ">backward</a> </dd>
<dd>
<a class="el" href="structLinear.html#a828a72af0a1ccac904325ee280dbefa4" title="update weights of all sublayers with gradients that must have been computed ">update</a> </dd></dl>

</div>
</div>
<a id="adb02d44e0558e4e26b9a550945cd3b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb02d44e0558e4e26b9a550945cd3b7e">&#9670;&nbsp;</a></span>forward_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __host__ void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::forward_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the baseline (serial) implementation of forward called both by cpu implementation (forward_cpu) and gpu implementation (forward_dev). the call sequence forward -&gt; forward_cpu -&gt; forward_base on cpu and and is forward -&gt; forward_gpu -&gt; forward_global -&gt; forward_dev -&gt; forward_base </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x)</td><td>input images </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aed0294f2d1c2013f66d89a52474352e5" title="calc the loss function of a mini-batch (x) ">forward</a> </dd>
<dd>
<a class="el" href="structLinear.html#a1d794073640bad48f9722f5d40b98902" title="a gpu version of baseline code called from the entry function (forward) ">forward_gpu</a> </dd>
<dd>
<a class="el" href="softmaxcrossentropy_8h.html#a578aeeb166bd06e800d9b396eab48b35" title="a global CUDA function that implements the baseline forward function for GPU ">forward_global</a> </dd>
<dd>
<a class="el" href="structLinear.html#a2b86dba92137500810cbf3ed95ee1fcb" title="the device function of forward called from the global (non-member) function ">forward_dev</a> </dd></dl>

</div>
</div>
<a id="a02f18ced52dc4bd6aa0ea45119c6a7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f18ced52dc4bd6aa0ea45119c6a7e0">&#9670;&nbsp;</a></span>forward_cpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::forward_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a cpu version of baseline code called from the entry function (forward) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x)</td><td>input images </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aed0294f2d1c2013f66d89a52474352e5" title="calc the loss function of a mini-batch (x) ">forward</a> </dd>
<dd>
<a class="el" href="structLinear.html#adb02d44e0558e4e26b9a550945cd3b7e" title="the baseline (serial) implementation of forward called both by cpu implementation (forward_cpu) and g...">forward_base</a> </dd></dl>

</div>
</div>
<a id="a2b86dba92137500810cbf3ed95ee1fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b86dba92137500810cbf3ed95ee1fcb">&#9670;&nbsp;</a></span>forward_dev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::forward_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the device function of forward called from the global (non-member) function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x)</td><td>input images </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aed0294f2d1c2013f66d89a52474352e5" title="calc the loss function of a mini-batch (x) ">forward</a> </dd>
<dd>
<a class="el" href="structLinear.html#a1d794073640bad48f9722f5d40b98902" title="a gpu version of baseline code called from the entry function (forward) ">forward_gpu</a> </dd>
<dd>
<a class="el" href="softmaxcrossentropy_8h.html#a578aeeb166bd06e800d9b396eab48b35" title="a global CUDA function that implements the baseline forward function for GPU ">forward_global</a> </dd>
<dd>
<a class="el" href="structLinear.html#adb02d44e0558e4e26b9a550945cd3b7e" title="the baseline (serial) implementation of forward called both by cpu implementation (forward_cpu) and g...">forward_base</a> </dd></dl>

</div>
</div>
<a id="a1d794073640bad48f9722f5d40b98902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d794073640bad48f9722f5d40b98902">&#9670;&nbsp;</a></span>forward_gpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::forward_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a gpu version of baseline code called from the entry function (forward) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x)</td><td>input images </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aed0294f2d1c2013f66d89a52474352e5" title="calc the loss function of a mini-batch (x) ">forward</a> </dd>
<dd>
<a class="el" href="softmaxcrossentropy_8h.html#a578aeeb166bd06e800d9b396eab48b35" title="a global CUDA function that implements the baseline forward function for GPU ">forward_global</a> </dd>
<dd>
<a class="el" href="structLinear.html#a2b86dba92137500810cbf3ed95ee1fcb" title="the device function of forward called from the global (non-member) function ">forward_dev</a> </dd>
<dd>
<a class="el" href="structLinear.html#adb02d44e0558e4e26b9a550945cd3b7e" title="the baseline (serial) implementation of forward called both by cpu implementation (forward_cpu) and g...">forward_base</a> </dd></dl>

</div>
</div>
<a id="af920adb0c630cddb4f8012984784807c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af920adb0c630cddb4f8012984784807c">&#9670;&nbsp;</a></span>gw_dot_gw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::gw_dot_gw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>take the inner product of gradients </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(o)</td><td>the object to take the inner product with</td></tr>
  </table>
  </dd>
</dl>
<p>take the inner product of this object's gradients and b's gradients </p>

</div>
</div>
<a id="a45f2c4c010a2451d39e0a7e736fd4a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f2c4c010a2451d39e0a7e736fd4a58">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmdline__opt.html">cmdline_opt</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlogger.html">logger</a> *&#160;</td>
          <td class="paramname"><em>lgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrnd__gen__t.html">rnd_gen_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(opt)</td><td>command line options </td></tr>
    <tr><td class="paramname">(lgr)</td><td>logger </td></tr>
    <tr><td class="paramname">(rg)</td><td>random number generator for initializing weights </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecf7edf669cf1182b49b604a2c9b3212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf7edf669cf1182b49b604a2c9b3212">&#9670;&nbsp;</a></span>make_dev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::make_dev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if the algorithm is a gpu algorithm, allocate a device shadow of this object and set dev field of this and all subobjects. otherwise it sets all dev fields to null. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#a0c6dcb67669d4984b6b9a676d4f14177" title="set the device pointer for this and all subobjects ">set_dev</a> </dd>
<dd>
<a class="el" href="structLinear.html#ad691fa515105ec71c69eed5f0ae03af6" title="if the algorithm is a gpu algorithm, dev field must not be null and deallocate it. ">del_dev</a> </dd></dl>

</div>
</div>
<a id="aab38b786325b4701080a89d5dab96f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab38b786325b4701080a89d5dab96f23">&#9670;&nbsp;</a></span>rand_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::rand_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrnd__gen__t.html">rnd_gen_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>randomly set all gradients to values between p and q </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(rg)</td><td>random number generator </td></tr>
    <tr><td class="paramname">(p)</td><td>minimum value of a component </td></tr>
    <tr><td class="paramname">(q)</td><td>maximum value of a component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c6dcb67669d4984b6b9a676d4f14177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6dcb67669d4984b6b9a676d4f14177">&#9670;&nbsp;</a></span>set_dev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::set_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt; *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the device pointer for this and all subobjects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(dev)</td><td>a device memory or null </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aecf7edf669cf1182b49b604a2c9b3212" title="if the algorithm is a gpu algorithm, allocate a device shadow of this object and set dev field of thi...">make_dev</a> </dd>
<dd>
<a class="el" href="structLinear.html#ad691fa515105ec71c69eed5f0ae03af6" title="if the algorithm is a gpu algorithm, dev field must not be null and deallocate it. ">del_dev</a></dd></dl>
<p>if dev is not null, dev fields of all subojects point to the corresponding subjects in the device memory. if dev is not null, all dev fields become null. </p>

</div>
</div>
<a id="a4faa818e70d779b80663b361a1e7ef75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faa818e70d779b80663b361a1e7ef75">&#9670;&nbsp;</a></span>set_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::set_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set all gradients to gradients of another object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(o)</td><td>the object from which gradients get copied</td></tr>
  </table>
  </dd>
</dl>
<p>transfer gradients of o to this object </p>

</div>
</div>
<a id="a828a72af0a1ccac904325ee280dbefa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828a72af0a1ccac904325ee280dbefa4">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update weights of all sublayers with gradients that must have been computed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(eta)</td><td>the learning rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#aed0294f2d1c2013f66d89a52474352e5" title="calc the loss function of a mini-batch (x) ">forward</a> </dd>
<dd>
<a class="el" href="structLinear.html#aeaa39d38b876fbd70794621955193fd3" title="calc the gradient of loss wrt the input (x) ">backward</a> </dd></dl>

</div>
</div>
<a id="aa59e1addd962ac7a70993229534ab899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59e1addd962ac7a70993229534ab899">&#9670;&nbsp;</a></span>update_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __host__ void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::update_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the baseline (serial) implementation of update called both by cpu implementation (update_cpu) and gpu implementation (update_dev). the call sequence update -&gt; update_cpu -&gt; update_base on cpu and and is update -&gt; update_gpu -&gt; update_global -&gt; update_dev -&gt; update_base </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(eta)</td><td>the learning rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#a828a72af0a1ccac904325ee280dbefa4" title="update weights of all sublayers with gradients that must have been computed ">update</a> </dd>
<dd>
<a class="el" href="structLinear.html#a8ca71565731b9d8c3ba552578c61753a" title="a gpu version of baseline code called from the entry function (update) ">update_gpu</a> </dd>
<dd>
<a class="el" href="linear_8h.html#a810703be28422bb9483665cbdbafd968" title="a global CUDA function that implements the baseline update function for GPU ">update_global</a> </dd>
<dd>
<a class="el" href="structLinear.html#ad45413b0c13ca0ca89db6a3217a8b00b" title="the device function of update called from the global (non-member) function ">update_dev</a> </dd></dl>

</div>
</div>
<a id="afabe5b3388c37c5b02e9f7ca7f0cd686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabe5b3388c37c5b02e9f7ca7f0cd686">&#9670;&nbsp;</a></span>update_cpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::update_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a cpu version of baseline code called from the entry function (update) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(eta)</td><td>the learning rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#a828a72af0a1ccac904325ee280dbefa4" title="update weights of all sublayers with gradients that must have been computed ">update</a> </dd>
<dd>
<a class="el" href="structLinear.html#aa59e1addd962ac7a70993229534ab899" title="the baseline (serial) implementation of update called both by cpu implementation (update_cpu) and gpu...">update_base</a> </dd></dl>

</div>
</div>
<a id="ad45413b0c13ca0ca89db6a3217a8b00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45413b0c13ca0ca89db6a3217a8b00b">&#9670;&nbsp;</a></span>update_dev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::update_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the device function of update called from the global (non-member) function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(eta)</td><td>the learning rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#a828a72af0a1ccac904325ee280dbefa4" title="update weights of all sublayers with gradients that must have been computed ">update</a> </dd>
<dd>
<a class="el" href="structLinear.html#a8ca71565731b9d8c3ba552578c61753a" title="a gpu version of baseline code called from the entry function (update) ">update_gpu</a> </dd>
<dd>
<a class="el" href="linear_8h.html#a810703be28422bb9483665cbdbafd968" title="a global CUDA function that implements the baseline update function for GPU ">update_global</a> </dd>
<dd>
<a class="el" href="structLinear.html#aa59e1addd962ac7a70993229534ab899" title="the baseline (serial) implementation of update called both by cpu implementation (update_cpu) and gpu...">update_base</a> </dd></dl>

</div>
</div>
<a id="a8ca71565731b9d8c3ba552578c61753a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca71565731b9d8c3ba552578c61753a">&#9670;&nbsp;</a></span>update_gpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::update_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a gpu version of baseline code called from the entry function (update) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(eta)</td><td>the learning rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structLinear.html#a828a72af0a1ccac904325ee280dbefa4" title="update weights of all sublayers with gradients that must have been computed ">update</a> </dd>
<dd>
<a class="el" href="linear_8h.html#a810703be28422bb9483665cbdbafd968" title="a global CUDA function that implements the baseline update function for GPU ">update_global</a> </dd>
<dd>
<a class="el" href="structLinear.html#ad45413b0c13ca0ca89db6a3217a8b00b" title="the device function of update called from the global (non-member) function ">update_dev</a> </dd>
<dd>
<a class="el" href="structLinear.html#aa59e1addd962ac7a70993229534ab899" title="the baseline (serial) implementation of update called both by cpu implementation (update_cpu) and gpu...">update_base</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a84bf1832fbbaccc87ca3e13b45f5acb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bf1832fbbaccc87ca3e13b45f5acb4">&#9670;&nbsp;</a></span>dev</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLinear.html">Linear</a>&lt;maxB,IC,nC&gt;* <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::dev</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>device shadow </p>

</div>
</div>
<a id="a62267914d63b5f94379e4f9caf6b317c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62267914d63b5f94379e4f9caf6b317c">&#9670;&nbsp;</a></span>gw</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray2.html">array2</a>&lt;IC,nC&gt; <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::gw</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>gradient of loss wrt to w </p>

</div>
</div>
<a id="abcdbaef350ab7abbcb459cfa87961bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdbaef350ab7abbcb459cfa87961bba">&#9670;&nbsp;</a></span>gx</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray4.html">array4</a>&lt;maxB,IC,1,1&gt; <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::gx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>gradient of loss wrt to input x </p>

</div>
</div>
<a id="acde13832b627b3c1113283e22bac77a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde13832b627b3c1113283e22bac77a7">&#9670;&nbsp;</a></span>lgr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlogger.html">logger</a>* <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::lgr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>logger </p>

</div>
</div>
<a id="ad6b0173f0baf5ce07b3cd7340d4ed0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b0173f0baf5ce07b3cd7340d4ed0d4">&#9670;&nbsp;</a></span>opt</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmdline__opt.html">cmdline_opt</a> <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::opt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>command line option </p>

</div>
</div>
<a id="a5abe6ceff587b423273808d94b392ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abe6ceff587b423273808d94b392ee8">&#9670;&nbsp;</a></span>w</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray2.html">array2</a>&lt;IC,nC&gt; <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::w</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>weight of the matrix </p>

</div>
</div>
<a id="a8a7c8ecf358de5e00589a722a0c4541c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7c8ecf358de5e00589a722a0c4541c">&#9670;&nbsp;</a></span>x_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray4.html">array4</a>&lt;maxB,IC,1,1&gt;* <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::x_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>address of input passed to forward </p>

</div>
</div>
<a id="a422f2130612692682fdd151b96899264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422f2130612692682fdd151b96899264">&#9670;&nbsp;</a></span>y</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t nC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray4.html">array4</a>&lt;maxB,nC,1,1&gt; <a class="el" href="structLinear.html">Linear</a>&lt; maxB, IC, nC &gt;::y</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>output of the forward </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/tau/public_html/lecture/parallel_distributed/2018/handson/tau/parallel-distributed-handson/20vgg/include/<a class="el" href="linear_8h_source.html">linear.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
