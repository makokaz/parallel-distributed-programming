<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vgg: Block&lt; maxB, IC, H, W, K, OC &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vgg
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structBlock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Block&lt; maxB, IC, H, W, K, OC &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>a block of three layers (convolution; batch normalization; relu)  
 <a href="structBlock.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="block_8h_source.html">block.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Block&lt; maxB, IC, H, W, K, OC &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structBlock__coll__graph.png" border="0" usemap="#Block_3_01maxB_00_01IC_00_01H_00_01W_00_01K_00_01OC_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="Block_3_01maxB_00_01IC_00_01H_00_01W_00_01K_00_01OC_01_4_coll__map" id="Block_3_01maxB_00_01IC_00_01H_00_01W_00_01K_00_01OC_01_4_coll__map">
<area shape="rect" id="node2" href="structRelu.html" title="Relu\&lt; maxB, OC, H, W \&gt;" alt="" coords="34,250,209,277"/>
<area shape="rect" id="node3" href="structcmdline__opt.html" title="command line options " alt="" coords="121,5,213,32"/>
<area shape="rect" id="node4" href="structlogger.html" title="logging object " alt="" coords="229,95,286,121"/>
<area shape="rect" id="node6" href="structBatchNormalization.html" title="BatchNormalization\l\&lt; maxB, OC, H, W \&gt;" alt="" coords="300,243,447,284"/>
<area shape="rect" id="node5" href="structtsc__t.html" title="timestamp " alt="" coords="356,5,407,32"/>
<area shape="rect" id="node7" href="structarray4.html" title="array4\&lt; maxB, IC, H, W \&gt;" alt="" coords="385,95,562,121"/>
<area shape="rect" id="node8" href="structvec.html" title="vec\&lt; IC \&gt;" alt="" coords="586,95,667,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a53eb5f86be4540cf491024b2b2783b42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a53eb5f86be4540cf491024b2b2783b42">init</a> (<a class="el" href="structcmdline__opt.html">cmdline_opt</a> <a class="el" href="structBlock.html#ad91e112b767ccd7035a37873cbc121a9">opt</a>, <a class="el" href="structlogger.html">logger</a> *<a class="el" href="structBlock.html#a8e037036c2020d2ac98fc0792d3f84f4">lgr</a>, <a class="el" href="structrnd__gen__t.html">rnd_gen_t</a> &amp;rg)</td></tr>
<tr class="memdesc:a53eb5f86be4540cf491024b2b2783b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize  <a href="#a53eb5f86be4540cf491024b2b2783b42">More...</a><br /></td></tr>
<tr class="separator:a53eb5f86be4540cf491024b2b2783b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10734345f8456513bbd7c792b51656af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a10734345f8456513bbd7c792b51656af">copy</a> ()</td></tr>
<tr class="memdesc:a10734345f8456513bbd7c792b51656af"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a copy of this  <a href="#a10734345f8456513bbd7c792b51656af">More...</a><br /></td></tr>
<tr class="separator:a10734345f8456513bbd7c792b51656af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11093fd68976a6a40155cfb42397653c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a11093fd68976a6a40155cfb42397653c">set_dev</a> (<a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt; *<a class="el" href="structBlock.html#a66767aae2045de05ce1dc09a92d164c4">dev</a>)</td></tr>
<tr class="memdesc:a11093fd68976a6a40155cfb42397653c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the device pointer for this and all subobjects  <a href="#a11093fd68976a6a40155cfb42397653c">More...</a><br /></td></tr>
<tr class="separator:a11093fd68976a6a40155cfb42397653c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971798b11f5cdc883880c0be2f143908"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a971798b11f5cdc883880c0be2f143908">make_dev</a> ()</td></tr>
<tr class="memdesc:a971798b11f5cdc883880c0be2f143908"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the algorithm is a gpu algorithm, allocate a device shadow of this object and set dev field of this and all subobjects. otherwise it sets all dev fields to null.  <a href="#a971798b11f5cdc883880c0be2f143908">More...</a><br /></td></tr>
<tr class="separator:a971798b11f5cdc883880c0be2f143908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e9e4f4dcffddc409fa2b20263ea3b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a46e9e4f4dcffddc409fa2b20263ea3b9">del_dev</a> ()</td></tr>
<tr class="memdesc:a46e9e4f4dcffddc409fa2b20263ea3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the algorithm is a gpu algorithm, dev field must not be null and deallocate it.  <a href="#a46e9e4f4dcffddc409fa2b20263ea3b9">More...</a><br /></td></tr>
<tr class="separator:a46e9e4f4dcffddc409fa2b20263ea3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfc150c9bbf7eb57ab9488a5096df8d"><td class="memItemLeft" align="right" valign="top"><a id="a5dfc150c9bbf7eb57ab9488a5096df8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a5dfc150c9bbf7eb57ab9488a5096df8d">to_dev</a> ()</td></tr>
<tr class="memdesc:a5dfc150c9bbf7eb57ab9488a5096df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the algorithm is a gpu algorithm, dev field must not be null and send the host data to the device memory <br /></td></tr>
<tr class="separator:a5dfc150c9bbf7eb57ab9488a5096df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0485907d27a19d4374e3ad09c5b9012"><td class="memItemLeft" align="right" valign="top"><a id="aa0485907d27a19d4374e3ad09c5b9012"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#aa0485907d27a19d4374e3ad09c5b9012">to_host</a> ()</td></tr>
<tr class="memdesc:aa0485907d27a19d4374e3ad09c5b9012"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the algorithm is a gpu algorithm, dev field must not be null and send the device data to the host memory <br /></td></tr>
<tr class="separator:aa0485907d27a19d4374e3ad09c5b9012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d431dfca3c47701c1c41e471ea17c8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a3d431dfca3c47701c1c41e471ea17c8b">update</a> (<a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> eta)</td></tr>
<tr class="memdesc:a3d431dfca3c47701c1c41e471ea17c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">update weights of all sublayers with gradients that must have been computed  <a href="#a3d431dfca3c47701c1c41e471ea17c8b">More...</a><br /></td></tr>
<tr class="separator:a3d431dfca3c47701c1c41e471ea17c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6ee3389b0ea5618109c9ca525ba9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray4.html">array4</a>&lt; maxB, OC, H, W &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a6a6ee3389b0ea5618109c9ca525ba9bf">forward</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, H, W &gt; &amp;x)</td></tr>
<tr class="memdesc:a6a6ee3389b0ea5618109c9ca525ba9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">calc the loss function of a mini-batch (x)  <a href="#a6a6ee3389b0ea5618109c9ca525ba9bf">More...</a><br /></td></tr>
<tr class="separator:a6a6ee3389b0ea5618109c9ca525ba9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b4cafe64fbb5d045b7f2bc401d9ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, H, W &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a86b4cafe64fbb5d045b7f2bc401d9ddc">backward</a> (<a class="el" href="structarray4.html">array4</a>&lt; maxB, OC, H, W &gt; &amp;gy)</td></tr>
<tr class="memdesc:a86b4cafe64fbb5d045b7f2bc401d9ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">calc the gradient of loss wrt the input (x)  <a href="#a86b4cafe64fbb5d045b7f2bc401d9ddc">More...</a><br /></td></tr>
<tr class="separator:a86b4cafe64fbb5d045b7f2bc401d9ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3752b971026c8a6506b34aef3c7e780b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a3752b971026c8a6506b34aef3c7e780b">rand_grad</a> (<a class="el" href="structrnd__gen__t.html">rnd_gen_t</a> &amp;rg, <a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> p, <a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> q)</td></tr>
<tr class="memdesc:a3752b971026c8a6506b34aef3c7e780b"><td class="mdescLeft">&#160;</td><td class="mdescRight">randomly set all gradients to values between p and q  <a href="#a3752b971026c8a6506b34aef3c7e780b">More...</a><br /></td></tr>
<tr class="separator:a3752b971026c8a6506b34aef3c7e780b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0db7335928b4b004b644f2ef3ac1bc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#ae0db7335928b4b004b644f2ef3ac1bc0">set_grad</a> (<a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt; &amp;o)</td></tr>
<tr class="memdesc:ae0db7335928b4b004b644f2ef3ac1bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set all gradients to gradients of another object  <a href="#ae0db7335928b4b004b644f2ef3ac1bc0">More...</a><br /></td></tr>
<tr class="separator:ae0db7335928b4b004b644f2ef3ac1bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a63d3357f60c7b097e97169b175445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a69a63d3357f60c7b097e97169b175445">gw_dot_gw</a> (<a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt; &amp;b)</td></tr>
<tr class="memdesc:a69a63d3357f60c7b097e97169b175445"><td class="mdescLeft">&#160;</td><td class="mdescRight">take the inner product of gradients  <a href="#a69a63d3357f60c7b097e97169b175445">More...</a><br /></td></tr>
<tr class="separator:a69a63d3357f60c7b097e97169b175445"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a66767aae2045de05ce1dc09a92d164c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a66767aae2045de05ce1dc09a92d164c4">dev</a></td></tr>
<tr class="separator:a66767aae2045de05ce1dc09a92d164c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91e112b767ccd7035a37873cbc121a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcmdline__opt.html">cmdline_opt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#ad91e112b767ccd7035a37873cbc121a9">opt</a></td></tr>
<tr class="separator:ad91e112b767ccd7035a37873cbc121a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e037036c2020d2ac98fc0792d3f84f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlogger.html">logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a8e037036c2020d2ac98fc0792d3f84f4">lgr</a></td></tr>
<tr class="separator:a8e037036c2020d2ac98fc0792d3f84f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac195c086bc1302e8324aa1d89067668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structConvolution2D.html">Convolution2D</a>&lt; maxB, IC, H, W, K, OC &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#aac195c086bc1302e8324aa1d89067668">conv</a></td></tr>
<tr class="separator:aac195c086bc1302e8324aa1d89067668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedad10fac693a934c1d72e24d478b6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBatchNormalization.html">BatchNormalization</a>&lt; maxB, OC, H, W &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#afedad10fac693a934c1d72e24d478b6b">bn</a></td></tr>
<tr class="separator:afedad10fac693a934c1d72e24d478b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019bcbd200d92669079eaa3c0c00ddfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRelu.html">Relu</a>&lt; maxB, OC, H, W &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBlock.html#a019bcbd200d92669079eaa3c0c00ddfc">relu</a></td></tr>
<tr class="separator:a019bcbd200d92669079eaa3c0c00ddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt;<br />
struct Block&lt; maxB, IC, H, W, K, OC &gt;</h3>

<p>a block of three layers (convolution; batch normalization; relu) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(maxB)</td><td>the maximum number of images (batch size) </td></tr>
    <tr><td class="paramname">(IC)</td><td>the number of channels per input image (the original input has typically three channels for RGB. in hidden layers, it starts from 64 and goes up to 512 in the last hidden layer) </td></tr>
    <tr><td class="paramname">(H)</td><td>height of an image (32 for an input image, down to 1 in the last hidden layer) </td></tr>
    <tr><td class="paramname">(W)</td><td>width of an image (32 for an input image, down to 1 in the last hidden layer) </td></tr>
    <tr><td class="paramname">(K)</td><td>convolution kernel size (1). filter array has (2K+1)*(2K+1) elems) </td></tr>
    <tr><td class="paramname">(OC)</td><td>the number of channels per an output image</td></tr>
  </table>
  </dd>
</dl>
<p>this layer applies convolution, batch normalization and relu in this order. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a86b4cafe64fbb5d045b7f2bc401d9ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b4cafe64fbb5d045b7f2bc401d9ddc">&#9670;&nbsp;</a></span>backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray4.html">array4</a>&lt;maxB,IC,H,W&gt;&amp; <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, OC, H, W &gt; &amp;&#160;</td>
          <td class="paramname"><em>gy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calc the gradient of loss wrt the input (x) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(gy)</td><td>gradient of loss with respect to the output</td></tr>
  </table>
  </dd>
</dl>
<p>calc the gradient of loss wrt the input. along the way, it also calculates the gradient of loss wrt weights for all sublayers that have weights. since this is the entire network, gy is actually a vector whose components are all 1. (loss = sum of losses of each data). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structBlock.html#a6a6ee3389b0ea5618109c9ca525ba9bf" title="calc the loss function of a mini-batch (x) ">forward</a> </dd>
<dd>
<a class="el" href="structBlock.html#a3d431dfca3c47701c1c41e471ea17c8b" title="update weights of all sublayers with gradients that must have been computed ">update</a> </dd></dl>

</div>
</div>
<a id="a10734345f8456513bbd7c792b51656af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10734345f8456513bbd7c792b51656af">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBlock.html">Block</a>&lt;maxB,IC,H,W,K,OC&gt;* <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make a copy of this </p>
<p>if this object has a device pointer, the copy will have a device pointer too, but its contents are NOT copied </p>

</div>
</div>
<a id="a46e9e4f4dcffddc409fa2b20263ea3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e9e4f4dcffddc409fa2b20263ea3b9">&#9670;&nbsp;</a></span>del_dev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::del_dev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if the algorithm is a gpu algorithm, dev field must not be null and deallocate it. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBlock.html#a971798b11f5cdc883880c0be2f143908" title="if the algorithm is a gpu algorithm, allocate a device shadow of this object and set dev field of thi...">make_dev</a> </dd>
<dd>
<a class="el" href="structBlock.html#a11093fd68976a6a40155cfb42397653c" title="set the device pointer for this and all subobjects ">set_dev</a> </dd></dl>

</div>
</div>
<a id="a6a6ee3389b0ea5618109c9ca525ba9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6ee3389b0ea5618109c9ca525ba9bf">&#9670;&nbsp;</a></span>forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray4.html">array4</a>&lt;maxB,OC,H,W&gt;&amp; <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray4.html">array4</a>&lt; maxB, IC, H, W &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calc the loss function of a mini-batch (x) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x)</td><td>input images </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBlock.html#a86b4cafe64fbb5d045b7f2bc401d9ddc" title="calc the gradient of loss wrt the input (x) ">backward</a> </dd>
<dd>
<a class="el" href="structBlock.html#a3d431dfca3c47701c1c41e471ea17c8b" title="update weights of all sublayers with gradients that must have been computed ">update</a> </dd></dl>

</div>
</div>
<a id="a69a63d3357f60c7b097e97169b175445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a63d3357f60c7b097e97169b175445">&#9670;&nbsp;</a></span>gw_dot_gw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a> <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::gw_dot_gw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>take the inner product of gradients </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(b)</td><td>the object to take the inner product with</td></tr>
  </table>
  </dd>
</dl>
<p>take the inner product of this object's gradients and b's gradients </p>

</div>
</div>
<a id="a53eb5f86be4540cf491024b2b2783b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53eb5f86be4540cf491024b2b2783b42">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcmdline__opt.html">cmdline_opt</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlogger.html">logger</a> *&#160;</td>
          <td class="paramname"><em>lgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrnd__gen__t.html">rnd_gen_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(opt)</td><td>command line options </td></tr>
    <tr><td class="paramname">(lgr)</td><td>logger </td></tr>
    <tr><td class="paramname">(rg)</td><td>random number generator for initializing weights </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a971798b11f5cdc883880c0be2f143908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971798b11f5cdc883880c0be2f143908">&#9670;&nbsp;</a></span>make_dev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::make_dev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if the algorithm is a gpu algorithm, allocate a device shadow of this object and set dev field of this and all subobjects. otherwise it sets all dev fields to null. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBlock.html#a11093fd68976a6a40155cfb42397653c" title="set the device pointer for this and all subobjects ">set_dev</a> </dd>
<dd>
<a class="el" href="structBlock.html#a46e9e4f4dcffddc409fa2b20263ea3b9" title="if the algorithm is a gpu algorithm, dev field must not be null and deallocate it. ">del_dev</a> </dd></dl>

</div>
</div>
<a id="a3752b971026c8a6506b34aef3c7e780b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3752b971026c8a6506b34aef3c7e780b">&#9670;&nbsp;</a></span>rand_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::rand_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrnd__gen__t.html">rnd_gen_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>randomly set all gradients to values between p and q </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(rg)</td><td>random number generator </td></tr>
    <tr><td class="paramname">(p)</td><td>minimum value of a component </td></tr>
    <tr><td class="paramname">(q)</td><td>maximum value of a component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11093fd68976a6a40155cfb42397653c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11093fd68976a6a40155cfb42397653c">&#9670;&nbsp;</a></span>set_dev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::set_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt; *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the device pointer for this and all subobjects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(dev)</td><td>a device memory or null </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBlock.html#a971798b11f5cdc883880c0be2f143908" title="if the algorithm is a gpu algorithm, allocate a device shadow of this object and set dev field of thi...">make_dev</a> </dd>
<dd>
<a class="el" href="structBlock.html#a46e9e4f4dcffddc409fa2b20263ea3b9" title="if the algorithm is a gpu algorithm, dev field must not be null and deallocate it. ">del_dev</a></dd></dl>
<p>if dev is not null, dev fields of all subojects point to the corresponding subjects in the device memory. if dev is not null, all dev fields become null. </p>

</div>
</div>
<a id="ae0db7335928b4b004b644f2ef3ac1bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0db7335928b4b004b644f2ef3ac1bc0">&#9670;&nbsp;</a></span>set_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::set_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set all gradients to gradients of another object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(o)</td><td>the object from which gradients get copied</td></tr>
  </table>
  </dd>
</dl>
<p>transfer gradients of o to this object </p>

</div>
</div>
<a id="a3d431dfca3c47701c1c41e471ea17c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d431dfca3c47701c1c41e471ea17c8b">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vgg__util_8h.html#a1082d08aaa761215ec83e7149f27ad16">real</a>&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update weights of all sublayers with gradients that must have been computed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(eta)</td><td>the learning rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structBlock.html#a6a6ee3389b0ea5618109c9ca525ba9bf" title="calc the loss function of a mini-batch (x) ">forward</a> </dd>
<dd>
<a class="el" href="structBlock.html#a86b4cafe64fbb5d045b7f2bc401d9ddc" title="calc the gradient of loss wrt the input (x) ">backward</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afedad10fac693a934c1d72e24d478b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedad10fac693a934c1d72e24d478b6b">&#9670;&nbsp;</a></span>bn</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBatchNormalization.html">BatchNormalization</a>&lt;maxB,OC,H,W&gt; <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::bn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>batch normalization layer </p>

</div>
</div>
<a id="aac195c086bc1302e8324aa1d89067668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac195c086bc1302e8324aa1d89067668">&#9670;&nbsp;</a></span>conv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structConvolution2D.html">Convolution2D</a>&lt;maxB,IC,H,W,K,OC&gt; <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::conv</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convolution layer </p>

</div>
</div>
<a id="a66767aae2045de05ce1dc09a92d164c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66767aae2045de05ce1dc09a92d164c4">&#9670;&nbsp;</a></span>dev</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBlock.html">Block</a>&lt;maxB,IC,H,W,K,OC&gt;* <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::dev</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>device shadow </p>

</div>
</div>
<a id="a8e037036c2020d2ac98fc0792d3f84f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e037036c2020d2ac98fc0792d3f84f4">&#9670;&nbsp;</a></span>lgr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlogger.html">logger</a>* <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::lgr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>logger </p>

</div>
</div>
<a id="ad91e112b767ccd7035a37873cbc121a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91e112b767ccd7035a37873cbc121a9">&#9670;&nbsp;</a></span>opt</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcmdline__opt.html">cmdline_opt</a> <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::opt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>command line option </p>

</div>
</div>
<a id="a019bcbd200d92669079eaa3c0c00ddfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019bcbd200d92669079eaa3c0c00ddfc">&#9670;&nbsp;</a></span>relu</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;idx_t maxB, idx_t IC, idx_t H, idx_t W, idx_t K, idx_t OC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRelu.html">Relu</a>&lt;maxB,OC,H,W&gt; <a class="el" href="structBlock.html">Block</a>&lt; maxB, IC, H, W, K, OC &gt;::relu</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>rectified linear layer </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/tau/public_html/lecture/parallel_distributed/2018/handson/tau/parallel-distributed-handson/20vgg/include/<a class="el" href="block_8h_source.html">block.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
